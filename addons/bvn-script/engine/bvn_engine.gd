@icon("../icons/bvn.svg")
@tool
extends BVN_SceneSet

class_name BVN_Engine

## Main Resource where the VN data is saved.
@export var visual_novel:BVN_VisualNovel:
	set(v):
		if cmd_runner:
			cmd_runner.visual_novel = v
		if speaker_runner:
			speaker_runner.visual_novel = v
		visual_novel = v

## Begins the VN Engine as soon as its ready.
@export var autoplay:bool = false

@export_group("Advanced Configuration")

## The CanvasLayer where the BVN Gui Elements are added to
## If not provided - The Engine will make one on runtime
@export var managed_canvas_override:CanvasLayer
@export var managed_canvas:CanvasLayer

var gui_canvas:CanvasLayer:
	get: return managed_canvas_override if managed_canvas_override else managed_canvas

var character_cache:Dictionary[String, BVN_CharacterSheet] = {}

var bdb := BdbThrottleByMsec.new(250)


#region services
var cmd_runner:BVNInternal_EngineCommandRunner
var speaker_runner:BVNInternal_SpeakerRunner

var gui_orchestrator:BvnInternal_GuiOrchestrator 
var session_service:BVNInternal_SessionService 
var scene_service:BVNInernal_SceneService
var lock_service:BVNInternal_LockService
#endregion


const AST_TYPE_UNSPECIFIED = Bvn_AstNode.TYPE_UNSPECIFIED
const AST_TYPE_NOOP = Bvn_AstNode.TYPE_NOOP
const AST_TYPE_SPEAK = Bvn_AstNode.TYPE_SPEAK
const AST_TYPE_COMMAND = Bvn_AstNode.TYPE_COMMAND
const AST_TYPE_IF = Bvn_AstNode.TYPE_IF
const AST_TYPE_ELSE_IF = Bvn_AstNode.TYPE_ELSE_IF
const AST_TYPE_ELSE = Bvn_AstNode.TYPE_ELSE

var service_node:Node

var debouncers:Dictionary[String,BdbDebounce] = {}
func _init() -> void:
	tree_entered.connect(func ():
		add_to_group(BVNInternal_Tags.ENGINE)
		
		if Engine.is_editor_hint():
			BVN_Settings.last_edited_engine = EditorInterface.get_edited_scene_root().scene_file_path
		
		if service_node == null:
			service_node = Node.new()
			service_node.name = "BVNI Services"
			add_child(service_node, true,Node.INTERNAL_MODE_BACK)
			
		#region CMD_RUNNER setup
		if cmd_runner == null:
			cmd_runner = BVNInternal_EngineCommandRunner.new()
			service_node.add_child(cmd_runner, true,Node.INTERNAL_MODE_BACK)
		#endregion
		
		#region SPEAKER_RUNNER
		if speaker_runner == null:
			speaker_runner = BVNInternal_SpeakerRunner.new()
			service_node.add_child(speaker_runner, true,Node.INTERNAL_MODE_BACK)
		#endregion
		
		#region SERVICES
		if session_service == null:
			session_service = BVNInternal_SessionService.new()
			service_node.add_child(session_service, true,Node.INTERNAL_MODE_BACK)
		if scene_service == null:
			scene_service = BVNInernal_SceneService.new()
			service_node.add_child(scene_service, true,Node.INTERNAL_MODE_BACK)
		if lock_service == null:
			lock_service = BVNInternal_LockService.new()
			service_node.add_child(lock_service, true,Node.INTERNAL_MODE_BACK) 
		#endregion 
		
		#region 
		if managed_canvas_override == null and managed_canvas == null:
			managed_canvas = CanvasLayer.new()
			managed_canvas.name = "BVN Internal Autogenerated Canvas"
			managed_canvas.layer = int(2147483647) # Max int
			add_child(managed_canvas, true)
		gui_orchestrator = BvnInternal_GuiOrchestrator.new()
		gui_orchestrator.gui_canvas = gui_canvas
		gui_orchestrator.name = "BvnInternal_GuiOrchestrator"
		service_node.add_child(gui_orchestrator, true, Node.INTERNAL_MODE_DISABLED)
		gui_orchestrator.owner = owner
		#endregion
		
		#region add debouncers
		debouncers.load = BdbDebounce.new(0.15)	
		service_node.add_child(debouncers.load, true, Node.INTERNAL_MODE_DISABLED)
		#endregion
		
		visual_novel = visual_novel # Force trigger propagations of visual novel
		BVN.engine = self
		)
	tree_exited.connect(func ():
		# Free all services
		if is_instance_valid(service_node): 
			service_node.free()
		)
		
		
	ready.connect(func ():
		if !Engine.is_editor_hint():
			BVN_EventBus.on_request_next_engine_action.connect(next)
			BVN_EventBus.on_request_load_session.connect(debouncers.load.cb(_load_game).handle, CONNECT_DEFERRED)
			if autoplay: 
				get_tree().create_timer(0.1).timeout.connect(start_visual_novel)
		)

func _load_game(..._unused:Array):
	start_visual_novel()

func _get_configuration_warnings() -> PackedStringArray:
	var errors:Array[String] = []
	if visual_novel == null:
		errors.append("Please add a visual novel resource")
		return errors
		
	if !visual_novel.characters:
		errors.append("No characters added to visual novel resource")
		
	var found_store:Array = BdbSelect.children_by_type(self, BVN_Variables)
	if not(found_store) or found_store.size() != 1:
		errors.append("Must have exactly one '%s' child" % (BVN_Variables as Script).get_global_name())
		
	var scene = BdbSelect.child_by_type(self, BVN_Scene)
	var scene_set = BdbSelect.child_by_type(self, BVN_SceneSet)
	if not(scene or scene_set):
		errors.append("Must have atleast one '%s' or '%s' child" % [
			(BVN_Scene as Script).get_global_name(),
			(BVN_SceneSet as Script).get_global_name()
		])

	return errors
	
var has_started := false
func start_visual_novel():
	has_started = true
	var scene:BVN_Scene = null
	#region FROM LOAD REQUEST
	if scene_service.scene_context:
		scene = scene_service.scene_context.scene
	#endregion
		
	#region NO STARTING
	elif scene_service.scenes:
		scene = BdbSelect.item_by_type(scene_service.scenes, BVN_Scene)
	#endregion
	assert(scene, "Couldn't find a scene to use")
	run_scene(scene)

## Context of the current running scene
var context:BVNInternal_SceneExecutionContext
func run_scene(scene:BVN_Scene):
	context = scene_service.mk_scene_context()
	
	var script := scene.scene_data.scene_script
	assert(script, "'%s' has no script. Start writing one now" % scene.get_scene_path())
	var root_node := script_parser.parse_bvn_script(scene.scene_data.scene_script)
	
	context.node_data = {}
	context.scene = scene
	context.current_node = root_node
	
	scene_service.push_scene(scene)
	next()

func next(next_node:Bvn_AstNode = null):
	if (
		lock_service.is_locked or 
		(!Engine.is_editor_hint() and !has_started)
	): 
		print("@@IGNORED")
		return
	
	var prev_node := context.current_node # Just storing for debugging reasons
	context.current_node = next_node if next_node else context.current_node.get_next_node()
	if context.current_node == null:
		var next_scene = BVN_EngineSelectors.find_next_scene(context.scene)
		assert(next_scene, "No more scenes left!")
		run_scene(next_scene)
		return

	var vars = BVNInternal_Query.variables.get_format_payload()
	vars[&".scene_path"] = context.scene.get_scene_path()
	execute_bvn_instruction(context.current_node, vars)
	
var script_parser:BVN_ScriptParser = BVN_ScriptParser.new()

## Returns an error string if any
const IF_ELSE_LIST = [Bvn_AstNode.TYPE_IF, Bvn_AstNode.TYPE_ELSE_IF]
enum IF_ELSE_STATE {
	FAILED = 0,
	PASSED = 1,
	SKIPPED = 2, 
}

func execute_bvn_instruction(ast_node:Bvn_AstNode, vars:Dictionary):
	var is_run_in_game = context # context gets created on PLAY only
				
	match ast_node.type:
		AST_TYPE_SPEAK:
			speaker_runner.load_ast_node(ast_node, vars)
			speaker_runner.run()
		AST_TYPE_COMMAND:
			var nodes_to_run:Array[Bvn_AstNode] = [ast_node]
			nodes_to_run.append_array(ast_node.children)
			
			for node_to_run in nodes_to_run:
				var result: = cmd_runner.execute_node(node_to_run, vars, context.scene if context else null)
				assert(result[0] == OK, "There was an error running the command '%s'" % node_to_run.text)

			if is_run_in_game:
				next(ast_node.get_next_node(false))
		AST_TYPE_IF:
			var collapse_result := cmd_runner.execute_ifelse_node(ast_node, vars, context.scene)
				
			if is_run_in_game:
				if collapse_result:
					context.node_data[ast_node] = {&"result": IF_ELSE_STATE.PASSED}
					next(ast_node.get_next_node())
				else:
					context.node_data[ast_node] = {&"result": IF_ELSE_STATE.FAILED}
					var next_sibling := ast_node.get_next_sibling()
					if next_sibling:
						next(next_sibling)
					else:
						next(ast_node.get_next_node())
		AST_TYPE_ELSE_IF:
			if is_run_in_game:
				
				var prev_sibling := ast_node.get_prev_sibling()
				if prev_sibling.type not in IF_ELSE_LIST:
					return &"'elif' without matching 'if' statement"
				var previous_sibling_result:IF_ELSE_STATE = context.node_data[prev_sibling].result
				if previous_sibling_result == IF_ELSE_STATE.FAILED:
					# only run node if prev is failed
					var collapse_result := cmd_runner.execute_ifelse_node(ast_node, vars, context.scene)
					if collapse_result:
						context.node_data[ast_node] = {&"result":IF_ELSE_STATE.PASSED}
						next(ast_node.get_next_node())
						return &""

				# if reached this point, it means we've attempted to evaluate or previous is a pass
				context.node_data[ast_node] = {&"result":IF_ELSE_STATE.SKIPPED}
				var next_sibling := ast_node.get_next_sibling()
				if next_sibling:
					next(next_sibling)
				else:
					next(ast_node.get_next_node())
				
		AST_TYPE_ELSE:
			if is_run_in_game:
				var prev_sibling := ast_node.get_prev_sibling()
				if prev_sibling.type not in IF_ELSE_LIST:
					return &"'else' without matching 'if' statement"
				var previous_sibling_result:IF_ELSE_STATE = context.node_data[prev_sibling].result
				if previous_sibling_result == IF_ELSE_STATE.FAILED:
					next(ast_node.get_next_node())
					return &""
				
				# if reached this point, it means we've attempted to evaluate or previous is a pass
				var next_sibling := ast_node.get_next_sibling()
				if next_sibling:
					next(next_sibling)
				else:
					next(ast_node.get_next_node(false))
		AST_TYPE_NOOP:
			# just move on to the next node, these children
			# will have been handled at the parent level
			next(ast_node.get_next_node(false)) 
		AST_TYPE_UNSPECIFIED when (ast_node.parent.type in [AST_TYPE_SPEAK, AST_TYPE_COMMAND]):
			# just move on to the next node, these children
			# will have been handled at the parent level
			next(ast_node.get_next_node(false)) 
			
		_:
			BdbError.not_implemented("Unsupported ast-node type %s " % ast_node.type)
